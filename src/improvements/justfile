# Create a new template or task
# e.g. just new [template|task]
new COMMAND="" TASK_TYPE="":
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    show_usage() {
        echo
        echo "Usage: just new [template|task]"
        echo "Available commands:"
        echo "  • template  - Create a new template"
        echo "  • task      - Create a new task"
        echo
    }

    show_task_types() {
        echo
        echo "Available task types:"
        echo "  • l2taskbase - 'L2TaskBase' task type, these tasks require a superchain address registry and can iterate over multiple L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/test/tasks/mock/template/GasConfigTemplate.sol"
        echo "  • simplebase - 'SimpleBase' task type, these tasks require simple key value registry and are independent of the L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/FinanceTemplate.sol"
        echo "  • opcmbasetask - 'OPCMBaseTask' task type, these tasks are used to make delegate calls to the Optimism Contracts Manager and are"
        echo "    dependent on the L2 chains and inherit from L2TaskBase"
        echo "    e.g.: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/OPCMUpgradeV200.sol"
        echo
    }
    
    # shellcheck disable=SC2050
    case "{{COMMAND}}" in
        "")
            echo -e "\n\033[31mError: No command specified\033[0m"
            show_usage
            exit 1
            ;;
        template)
            if [ -z "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: No task type specified\033[0m"
                show_task_types
                exit 1
            fi

            case "{{TASK_TYPE}}" in
                l2taskbase)
                    TASK_TYPE="L2TaskBase"
                    ;;
                simplebase)
                    TASK_TYPE="SimpleBase"
                    ;;
                opcmbasetask)
                    TASK_TYPE="OPCMBaseTask"
                    ;;
                *)
                    echo -e "\n\033[31mError: Invalid task type '{{TASK_TYPE}}'\033[0m"
                    show_task_types
                    exit 1
                    ;;
            esac
            ./script/create-template.sh "$TASK_TYPE"
            ;;
        task)
            if [ -n "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: Task type should not be specified for 'task' command\033[0m"
                exit 1
            fi
            ./script/create-task.sh
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m"
            show_usage
            exit 1
            ;;
    esac

task COMMAND="" NETWORK="":
    #!/usr/bin/env bash
    set -euo pipefail

    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    if [ "{{COMMAND}}" = "" ]; then
        echo -e "\n\033[31mError: No command specified\033[0m\n"
        exit 1
    fi

    # shellcheck disable=SC2194
    case "{{COMMAND}}" in
        ls)
            echo ""
            ./script/sorted-tasks.sh {{NETWORK}}
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m\n"
            exit 1
            ;;
    esac
    
monorepo-integration-test COMMAND="":
    #!/usr/bin/env bash
    set -euo pipefail

    # Set FOUNDRY_PROFILE, defaulting to 'default' if not already set.
    export FOUNDRY_PROFILE="${FOUNDRY_PROFILE:-default}"
    echo "Currently running with FOUNDRY_PROFILE: ${FOUNDRY_PROFILE}"

    root_dir=$(git rev-parse --show-toplevel)
    allocs_path="${root_dir}/lib/optimism/packages/contracts-bedrock/allocs.json"

    # Running this command with mainnet RPC URL.
    ETH_RPC_URL=$(yq eval ".profile.\"${FOUNDRY_PROFILE}\".rpc_endpoints.mainnet" "${root_dir}/foundry.toml")
    export ETH_RPC_URL
    echo "Using mainnet RPC: ${ETH_RPC_URL}"
    
    # For now, we are running monorepo integration tests for the example eth tasks only.
    mainnet_network_task_dir="eth" 

    forge build
    forge script ${root_dir}/src/improvements/tasks/TaskRunner.sol:TaskRunner --sig "run(string,string)" ${allocs_path} ${mainnet_network_task_dir} --ffi --rpc-url $ETH_RPC_URL
    export SUPERCHAIN_OPS_ALLOCS_PATH=./allocs.json
    cd ${root_dir}/lib/optimism/packages/contracts-bedrock/

    export NO_MATCH_CONTRACTS="OptimismPortal2WithMockERC20_Test\|OptimismPortal2_FinalizeWithdrawal_Test\|AnchorStateRegistry_*\|FaultDisputeGame_Test\|PermissionedDisputeGame_Test\|FaultDispute_1v1_Actors_Test\|DelayedWETH_Hold_Test"
    # shellcheck disable=SC2194
    case "{{COMMAND}}" in
        rerun)
            just test-upgrade-rerun --no-match-contract "${NO_MATCH_CONTRACTS}"
            ;;
        *)
            just test-upgrade --no-match-contract "${NO_MATCH_CONTRACTS}"
            ;;
    esac
    rm -f ${allocs_path} # clean up

check-superchain-registry-latest:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    bash ${root_dir}/src/improvements/script/check-superchain-latest.sh

# this is command is mainly for CI testing purposes and not task developers
# task developers can run this locally, however it is expected that this
# command will be run mostly by CI.
simulate-all-templates:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    forge build

    # If the task is nested then we only simulate as the foundation.
    # In the future we could simulate as other nested safes. 
    # For testing purposes, we do not gain anything by simulating as other nested safes.
    nested_safe_name="foundation"
    simulation_count=0
    for task in ${root_dir}/test/tasks/example/*/*; do
        if [ -d "$task" ]; then
            echo "Simulating task: $task"
            ${root_dir}/src/improvements/script/simulate-task.sh $task $nested_safe_name
            simulation_count=$((simulation_count + 1))
        fi
    done
    echo "$simulation_count simulations run."
    template_count=$(find "${root_dir}/src/improvements/template" -type f ! -name "*.template.sol" | wc -l)

    if [ "$simulation_count" -ne "$template_count" ]; then
        echo "Not all templates files have a corresponding task. Please add a task for a template in ${root_dir}/src/improvements/tasks/example" >&2
        exit 1
    fi

# Simulate a task locally and against Tenderly.
# TASK: The fullpath to the task to simulate.
# SAFE_NAME: The name of the safe to simulate the task for (council, foundation). Leave blank for non-nested tasks.
#
# Example:
# cd src/improvements
# just simulate-tenderly tasks/sep/000-opcm-upgrade-v200 council
# just simulate-tenderly tasks/sep/003-unichain-superchain-config-fix
simulate-tenderly TASK="" SAFE_NAME="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    forge build

    # If the task path does not start with a slash, append the current directory to the task path
    task_path="{{TASK}}"
    if [[ "$task_path" != /* ]]; then
        task_path="${PWD}/${task_path}"
    fi

    ${root_dir}/src/improvements/script/simulate-verify-task.sh "$task_path" {{SAFE_NAME}}

# Simulate all ready-to-sign tasks locally and against Tenderly, then verify the domain separator and message hash match against the values in the VALIDATION.md file.
#
# Parses an array of safes to verify from the config.toml file, with the short name used in the scripts, and the human readable name used in the VALIDATION.md file.
# signers = [
#     {longName = "Optimism Foundation", shortName = "foundation"},
#     {longName = "Security Council", shortName = "council"}
# ]
#
# Parses these strings from the VALIDATION.md file:
# ### <safe long name (from config.toml)>
# Domain Hash: `<hash>`
# Message Hash: `<hash>`
verify-ready-tasks:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)

    forge build

    for task in ${root_dir}/src/improvements/tasks/*/*; do
        if [ -d "$task" ]; then
            echo "Task: $task"

            # Read the README.md file and skip if it does not contain "Status:.*READY.*"
            readme_file="${task}/README.md"
            if [ -f "$readme_file" ]; then
                if ! grep -q "Status:.*READY.*" "$readme_file"; then
                    echo -e "$(grep "Status:" $readme_file)"
                    echo -e "Skipping task\n"
                    continue
                fi
            fi

            # Check that we have a validations file and exit if not
            validation_md="${task}/VALIDATION.md"
            if [ ! -f "$validation_md" ]; then
                echo "Error: No VALIDATION.md file found for task $task"
                exit 1
            fi

            # Check that we have a config.toml file and exit if not
            config_toml="${task}/config.toml"
            if [ ! -f "$config_toml" ]; then
                echo "Error: No config.toml file found for task $task"
                exit 1
            fi

            # Use yq to extract the signers section from the config and convert to JSON
            signers=$(yq -p=toml -o=json eval '.signers' "$config_toml")

            # Exit if $signers is null
            if [ "$signers" = "null" ]; then
                echo "Error: No signers found in config.toml for task $task"
                exit 1
            fi

            # Loop over the signers and extract the validation and short safe names
            echo "$signers" | jq -c '.[]' | while read -r signer; do
                readable_name=$(echo "$signer" | jq -r '.longName')
                short_name=$(echo "$signer" | jq -r '.shortName')
                echo "Verifying hashes for $readable_name"

                # Look for the validation name in the validation file, and then extract the domain separator and message hash
                if grep -q "### ${readable_name}" "$validation_md"; then
                    domain_separator=$(grep -A 2 "### ${readable_name}" "$validation_md" | grep "Domain Hash:" | grep -o '`[^`]*`' | tr -d '`')
                    message_hash=$(grep -A 3 "### ${readable_name}" "$validation_md" | grep "Message Hash:" | grep -o '`[^`]*`' | tr -d '`')
                    echo "Target Domain Separator: $domain_separator"
                    echo "Target Message Hash: $message_hash"

                    # Simulate and verify the task
                    ${root_dir}/src/improvements/script/simulate-tenderly.sh $task $short_name $domain_separator $message_hash

                else
                    echo "Error: No hashes found in VALIDATIONS.md for $readable_name"
                    exit 1
                fi
            done
        fi
    done
