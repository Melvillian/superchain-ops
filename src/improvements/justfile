# Create a new template or task
# e.g. just new [template|task]
new COMMAND="":
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    show_usage() {
        echo
        echo "Usage: just new [template|task]"
        echo "Available commands:"
        echo "  • template  - Create a new template"
        echo "  • task      - Create a new task"
        echo
    }
    
    # shellcheck disable=SC2050
    if [ "{{COMMAND}}" = "" ]; then
        echo -e "\n\033[31mError: No command specified\033[0m"
        show_usage
        exit 1
    fi
    
    # shellcheck disable=SC2194
    case "{{COMMAND}}" in
        template)
            ./script/create-template.sh
            ;;
        task)    
            ./script/create-task.sh
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m"
            show_usage
            exit 1
            ;;
    esac

task COMMAND="" NETWORK="":
    #!/usr/bin/env bash
    set -euo pipefail

    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    if [ "{{COMMAND}}" = "" ]; then
        echo -e "\n\033[31mError: No command specified\033[0m\n"
        exit 1
    fi

    # shellcheck disable=SC2194
    case "{{COMMAND}}" in
        ls)
            echo ""
            ./script/sorted-tasks.sh {{NETWORK}}
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m\n"
            exit 1
            ;;
    esac
    
monorepo-integration-test COMMAND="":
    #!/usr/bin/env bash
    set -euo pipefail

    # Set FOUNDRY_PROFILE, defaulting to 'default' if not already set.
    export FOUNDRY_PROFILE="${FOUNDRY_PROFILE:-default}"
    echo "Currently running with FOUNDRY_PROFILE: ${FOUNDRY_PROFILE}"

    root_dir=$(git rev-parse --show-toplevel)
    allocs_path="${root_dir}/lib/optimism/packages/contracts-bedrock/allocs.json"

    # Running this command with mainnet RPC URL.
    ETH_RPC_URL=$(yq eval ".profile.\"${FOUNDRY_PROFILE}\".rpc_endpoints.mainnet" "${root_dir}/foundry.toml")
    export ETH_RPC_URL
    echo "Using mainnet RPC: ${ETH_RPC_URL}"
    
    # For now, we are running monorepo integration tests for the example eth tasks only.
    mainnet_network_task_dir="eth" 

    forge build
    forge script ${root_dir}/src/improvements/tasks/TaskRunner.sol:TaskRunner --sig "run(string,string)" ${allocs_path} ${mainnet_network_task_dir} --ffi --rpc-url $ETH_RPC_URL
    export SUPERCHAIN_OPS_ALLOCS_PATH=./allocs.json
    cd ${root_dir}/lib/optimism/packages/contracts-bedrock/

    export NO_MATCH_CONTRACTS="OptimismPortal2WithMockERC20_Test\|OptimismPortal2_FinalizeWithdrawal_Test\|AnchorStateRegistry_*\|FaultDisputeGame_Test\|PermissionedDisputeGame_Test\|FaultDispute_1v1_Actors_Test\|DelayedWETH_Hold_Test"
    # shellcheck disable=SC2194
    case "{{COMMAND}}" in
        rerun)
            just test-upgrade-rerun --no-match-contract "${NO_MATCH_CONTRACTS}"
            ;;
        *)
            just test-upgrade --no-match-contract "${NO_MATCH_CONTRACTS}"
            ;;
    esac
    rm -f ${allocs_path} # clean up

check-superchain-registry-latest:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    bash ${root_dir}/src/improvements/script/check-superchain-latest.sh

simulate-all-templates:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    forge build

    # If the task is nested then we only simulate as the foundation.
    # In the future we could simulate as other nested safes. 
    # For testing purposes, we do not gain anything by simulating as other nested safes.
    nested_safe_name="foundation"
    simulation_count=0
    for task in ${root_dir}/src/improvements/tasks/example/*/*; do
        if [ -d "$task" ]; then
            ${root_dir}/src/improvements/script/simulate-verify-task.sh $task $nested_safe_name
            simulation_count=$((simulation_count + 1))
        fi
    done
    echo "$simulation_count simulations run."
    template_count=$(find "${root_dir}/src/improvements/template" -type f ! -name "*.template.sol" | wc -l)

    if [ "$simulation_count" -ne "$template_count" ]; then
        echo "Not all templates files have a corresponding task. Please add a task for a template in ${root_dir}/src/improvements/tasks/example" >&2
        exit 1
    fi

simulate-verify-task TASK="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)

    forge build

    # If the task is nested then we only simulate as the foundation.
    # In the future we could simulate as other nested safes. 
    # For testing purposes, we do not gain anything by simulating as other nested safes.
    nested_safe_name="foundation"

    ${root_dir}/src/improvements/script/simulate-verify-task.sh {{TASK}} $nested_safe_name

simulate-non-terminal-tasks:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    forge build

    # If the task is nested then we only simulate as the foundation.
    # In the future we could simulate as other nested safes. 
    # For testing purposes, we do not gain anything by simulating as other nested safes.
    nested_safe_name="foundation"

    # Later this networks list should be dynamically generated from the src/improvements/tasks directory.
    for task in ${root_dir}/src/improvements/tasks/example/*/*; do
        # Skip tasks marked as SIGNED or EXECUTED
        status=$(grep -i "Status:" "$task/README.md" | sed -n 's/.*Status: \[\(.*\)\].*/\1/p')
        if [ "$status" = "SIGNED" ] || [ "$status" = "EXECUTED" ]; then
            echo "Skipping task $(basename "$task") with status: $status"
            continue
        fi

        local_output_file="${root_dir}/src/improvements/script/simulate-non-terminal-tasks.log"
        ${root_dir}/src/improvements/script/simulate-verify-task.sh $task $nested_safe_name | tee "$local_output_file"

        # Parse the domain separator and message hash from the VALIDATIONS.md file, if it exists.
        if [ -f "$task/VALIDATIONS.md" ]; then
            domain_separator_validations=$(grep -i "Domain Hash:" "$task/VALIDATIONS.md" | grep -o '0x[a-fA-F0-9]\{64\}')
            message_hash_validations=$(grep -i "Message Hash:" "$task/VALIDATIONS.md" | grep -o '0x[a-fA-F0-9]\{64\}')
            echo "  VALIDATIONS Domain separator: $domain_separator_validations"
            echo "  VALIDATIONS Message hash: $message_hash_validations"
        else
            echo -e "\n\n\033[1;31mNo VALIDATIONS.md file found for task $(basename "$task")\033[0m\n"
            exit 1
        fi

        # Obtain the domain separator and message hash from local simulation
        domain_separator_local=$(awk '/Forge Domain Separator:/{print $4}' "$local_output_file")
        message_hash_local=$(awk '/Forge Message Hash:/{print $4}' "$local_output_file")

        # Obtain the domain separator and message hash from remote simulation
        domain_separator_remote=$(awk '/Remote Domain Separator:/{print $4}' "$local_output_file")
        message_hash_remote=$(awk '/Remote Message Hash:/{print $4}' "$local_output_file")

        # Compare the local hashes to the VALIDATIONS.md file
        if [ "$domain_separator_local" != "$domain_separator_validations" ]; then
            echo -e "\n\n\033[1;31mDomain separator mismatch VALIDATIONS/LOCAL\033[0m\n"
            exit 1
        fi
        if [ "$message_hash_local" != "$message_hash_validations" ]; then
            echo -e "\n\n\033[1;31mMessage hash mismatch VALIDATIONS/LOCAL\033[0m\n"
            exit 1
        fi

        # Compare the remote hashes to the VALIDATIONS.md file
        if [ "$domain_separator_remote" != "$domain_separator_validations" ]; then
            echo -e "\n\n\033[1;31mDomain separator mismatch VALIDATIONS/REMOTE\033[0m\n"
            exit 1
        fi  
        if [ "$message_hash_remote" != "$message_hash_validations" ]; then
            echo -e "\n\n\033[1;31mMessage hash mismatch VALIDATIONS/REMOTE\033[0m\n"
            exit 1
        fi

        echo -e "\n\n\033[1;32mRemote/Local/VALIDATIONS Domain separator and message hash match\033[0m\n"
        rm "$local_output_file"

    done
    echo "Done simulating non-terminal tasks"
